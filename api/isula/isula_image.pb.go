// Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.
// iSulad-img licensed under the Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//     http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
// PURPOSE.
// See the Mulan PSL v2 for more details.
// Description: iSulad image kit
// Author: liuhao
// Create: 2019-07-12

// Since some of this code is derived from Kubernetes, their copyright
// is retained here....
//
// Copyright 2018 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The original version of this proto can be found at
// https://github.com/cri-o/cri-o/blob/master/vendor/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.proto

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.21.0
// 	protoc        v3.9.0
// source: isula_image.proto

package isula

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Protocol int32

const (
	Protocol_TCP Protocol = 0
	Protocol_UDP Protocol = 1
)

// Enum value maps for Protocol.
var (
	Protocol_name = map[int32]string{
		0: "TCP",
		1: "UDP",
	}
	Protocol_value = map[string]int32{
		"TCP": 0,
		"UDP": 1,
	}
)

func (x Protocol) Enum() *Protocol {
	p := new(Protocol)
	*p = x
	return p
}

func (x Protocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Protocol) Descriptor() protoreflect.EnumDescriptor {
	return file_isula_image_proto_enumTypes[0].Descriptor()
}

func (Protocol) Type() protoreflect.EnumType {
	return &file_isula_image_proto_enumTypes[0]
}

func (x Protocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Protocol.Descriptor instead.
func (Protocol) EnumDescriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{0}
}

type MountPropagation int32

const (
	// No mount propagation ("private" in Linux terminology).
	MountPropagation_PROPAGATION_PRIVATE MountPropagation = 0
	// Mounts get propagated from the host to the container ("rslave" in Linux).
	MountPropagation_PROPAGATION_HOST_TO_CONTAINER MountPropagation = 1
	// Mounts get propagated from the host to the container and from the
	// container to the host ("rshared" in Linux).
	MountPropagation_PROPAGATION_BIDIRECTIONAL MountPropagation = 2
)

// Enum value maps for MountPropagation.
var (
	MountPropagation_name = map[int32]string{
		0: "PROPAGATION_PRIVATE",
		1: "PROPAGATION_HOST_TO_CONTAINER",
		2: "PROPAGATION_BIDIRECTIONAL",
	}
	MountPropagation_value = map[string]int32{
		"PROPAGATION_PRIVATE":           0,
		"PROPAGATION_HOST_TO_CONTAINER": 1,
		"PROPAGATION_BIDIRECTIONAL":     2,
	}
)

func (x MountPropagation) Enum() *MountPropagation {
	p := new(MountPropagation)
	*p = x
	return p
}

func (x MountPropagation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MountPropagation) Descriptor() protoreflect.EnumDescriptor {
	return file_isula_image_proto_enumTypes[1].Descriptor()
}

func (MountPropagation) Type() protoreflect.EnumType {
	return &file_isula_image_proto_enumTypes[1]
}

func (x MountPropagation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MountPropagation.Descriptor instead.
func (MountPropagation) EnumDescriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{1}
}

type HealthCheckRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *HealthCheckRequest) Reset() {
	*x = HealthCheckRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HealthCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckRequest) ProtoMessage() {}

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{0}
}

type HealthCheckResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *HealthCheckResponse) Reset() {
	*x = HealthCheckResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HealthCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckResponse) ProtoMessage() {}

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{1}
}

func (x *HealthCheckResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *HealthCheckResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type LoginRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Server   string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() {
	*x = LoginRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginRequest) ProtoMessage() {}

func (x *LoginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{2}
}

func (x *LoginRequest) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *LoginRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *LoginRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type LoginResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *LoginResponse) Reset() {
	*x = LoginResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginResponse) ProtoMessage() {}

func (x *LoginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{3}
}

func (x *LoginResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *LoginResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type LogoutRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
}

func (x *LogoutRequest) Reset() {
	*x = LogoutRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogoutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutRequest) ProtoMessage() {}

func (x *LogoutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{4}
}

func (x *LogoutRequest) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

type LogoutResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *LogoutResponse) Reset() {
	*x = LogoutResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogoutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutResponse) ProtoMessage() {}

func (x *LogoutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{5}
}

func (x *LogoutResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *LogoutResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerExportRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
	Output string `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	Uid    uint32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid    uint32 `protobuf:"varint,4,opt,name=gid,proto3" json:"gid,omitempty"`
	Offset uint32 `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *ContainerExportRequest) Reset() {
	*x = ContainerExportRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerExportRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerExportRequest) ProtoMessage() {}

func (x *ContainerExportRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerExportRequest.ProtoReflect.Descriptor instead.
func (*ContainerExportRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{6}
}

func (x *ContainerExportRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

func (x *ContainerExportRequest) GetOutput() string {
	if x != nil {
		return x.Output
	}
	return ""
}

func (x *ContainerExportRequest) GetUid() uint32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

func (x *ContainerExportRequest) GetGid() uint32 {
	if x != nil {
		return x.Gid
	}
	return 0
}

func (x *ContainerExportRequest) GetOffset() uint32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type ContainerExportResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerExportResponse) Reset() {
	*x = ContainerExportResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerExportResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerExportResponse) ProtoMessage() {}

func (x *ContainerExportResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerExportResponse.ProtoReflect.Descriptor instead.
func (*ContainerExportResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{7}
}

func (x *ContainerExportResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerExportResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type LoadImageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	File string `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Tag  string `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (x *LoadImageRequest) Reset() {
	*x = LoadImageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadImageRequest) ProtoMessage() {}

func (x *LoadImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadImageRequest.ProtoReflect.Descriptor instead.
func (*LoadImageRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{8}
}

func (x *LoadImageRequest) GetFile() string {
	if x != nil {
		return x.File
	}
	return ""
}

func (x *LoadImageRequest) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

type LoadImageResponose struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Outmsg string `protobuf:"bytes,1,opt,name=outmsg,proto3" json:"outmsg,omitempty"`
	Errmsg string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *LoadImageResponose) Reset() {
	*x = LoadImageResponose{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadImageResponose) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadImageResponose) ProtoMessage() {}

func (x *LoadImageResponose) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadImageResponose.ProtoReflect.Descriptor instead.
func (*LoadImageResponose) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{9}
}

func (x *LoadImageResponose) GetOutmsg() string {
	if x != nil {
		return x.Outmsg
	}
	return ""
}

func (x *LoadImageResponose) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *LoadImageResponose) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ImportRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	File string `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Tag  string `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (x *ImportRequest) Reset() {
	*x = ImportRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImportRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportRequest) ProtoMessage() {}

func (x *ImportRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportRequest.ProtoReflect.Descriptor instead.
func (*ImportRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{10}
}

func (x *ImportRequest) GetFile() string {
	if x != nil {
		return x.File
	}
	return ""
}

func (x *ImportRequest) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

type ImportResponose struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Errmsg string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ImportResponose) Reset() {
	*x = ImportResponose{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImportResponose) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportResponose) ProtoMessage() {}

func (x *ImportResponose) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportResponose.ProtoReflect.Descriptor instead.
func (*ImportResponose) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{11}
}

func (x *ImportResponose) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ImportResponose) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ImportResponose) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type GraphdriverStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GraphdriverStatusRequest) Reset() {
	*x = GraphdriverStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GraphdriverStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphdriverStatusRequest) ProtoMessage() {}

func (x *GraphdriverStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphdriverStatusRequest.ProtoReflect.Descriptor instead.
func (*GraphdriverStatusRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{12}
}

type GraphdriverStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Errmsg string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *GraphdriverStatusResponse) Reset() {
	*x = GraphdriverStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GraphdriverStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphdriverStatusResponse) ProtoMessage() {}

func (x *GraphdriverStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphdriverStatusResponse.ProtoReflect.Descriptor instead.
func (*GraphdriverStatusResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{13}
}

func (x *GraphdriverStatusResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *GraphdriverStatusResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *GraphdriverStatusResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type GraphdriverMetadataRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
}

func (x *GraphdriverMetadataRequest) Reset() {
	*x = GraphdriverMetadataRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GraphdriverMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphdriverMetadataRequest) ProtoMessage() {}

func (x *GraphdriverMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphdriverMetadataRequest.ProtoReflect.Descriptor instead.
func (*GraphdriverMetadataRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{14}
}

func (x *GraphdriverMetadataRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

type GraphdriverMetadataResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Metadata map[string]string `protobuf:"bytes,1,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Name     string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Errmsg   string            `protobuf:"bytes,3,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc       uint32            `protobuf:"varint,4,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *GraphdriverMetadataResponse) Reset() {
	*x = GraphdriverMetadataResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GraphdriverMetadataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphdriverMetadataResponse) ProtoMessage() {}

func (x *GraphdriverMetadataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphdriverMetadataResponse.ProtoReflect.Descriptor instead.
func (*GraphdriverMetadataResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{15}
}

func (x *GraphdriverMetadataResponse) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *GraphdriverMetadataResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GraphdriverMetadataResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *GraphdriverMetadataResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerFsUsageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
}

func (x *ContainerFsUsageRequest) Reset() {
	*x = ContainerFsUsageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerFsUsageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerFsUsageRequest) ProtoMessage() {}

func (x *ContainerFsUsageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerFsUsageRequest.ProtoReflect.Descriptor instead.
func (*ContainerFsUsageRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{16}
}

func (x *ContainerFsUsageRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

type ContainerFsUsageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Usage  string `protobuf:"bytes,1,opt,name=usage,proto3" json:"usage,omitempty"`
	Errmsg string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerFsUsageResponse) Reset() {
	*x = ContainerFsUsageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerFsUsageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerFsUsageResponse) ProtoMessage() {}

func (x *ContainerFsUsageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerFsUsageResponse.ProtoReflect.Descriptor instead.
func (*ContainerFsUsageResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{17}
}

func (x *ContainerFsUsageResponse) GetUsage() string {
	if x != nil {
		return x.Usage
	}
	return ""
}

func (x *ContainerFsUsageResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerFsUsageResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerUmountRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
	Force  bool   `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
}

func (x *ContainerUmountRequest) Reset() {
	*x = ContainerUmountRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerUmountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerUmountRequest) ProtoMessage() {}

func (x *ContainerUmountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerUmountRequest.ProtoReflect.Descriptor instead.
func (*ContainerUmountRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{18}
}

func (x *ContainerUmountRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

func (x *ContainerUmountRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type ContainerUmountResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerUmountResponse) Reset() {
	*x = ContainerUmountResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerUmountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerUmountResponse) ProtoMessage() {}

func (x *ContainerUmountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerUmountResponse.ProtoReflect.Descriptor instead.
func (*ContainerUmountResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{19}
}

func (x *ContainerUmountResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerUmountResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerMountRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
}

func (x *ContainerMountRequest) Reset() {
	*x = ContainerMountRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerMountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerMountRequest) ProtoMessage() {}

func (x *ContainerMountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerMountRequest.ProtoReflect.Descriptor instead.
func (*ContainerMountRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{20}
}

func (x *ContainerMountRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

type ContainerMountResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerMountResponse) Reset() {
	*x = ContainerMountResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerMountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerMountResponse) ProtoMessage() {}

func (x *ContainerMountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerMountResponse.ProtoReflect.Descriptor instead.
func (*ContainerMountResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{21}
}

func (x *ContainerMountResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerMountResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerRemoveRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NameId string `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`
}

func (x *ContainerRemoveRequest) Reset() {
	*x = ContainerRemoveRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerRemoveRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerRemoveRequest) ProtoMessage() {}

func (x *ContainerRemoveRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerRemoveRequest.ProtoReflect.Descriptor instead.
func (*ContainerRemoveRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{22}
}

func (x *ContainerRemoveRequest) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

type ContainerRemoveResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerRemoveResponse) Reset() {
	*x = ContainerRemoveResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerRemoveResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerRemoveResponse) ProtoMessage() {}

func (x *ContainerRemoveResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerRemoveResponse.ProtoReflect.Descriptor instead.
func (*ContainerRemoveResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{23}
}

func (x *ContainerRemoveResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerRemoveResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ContainerPrepareRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Image       string   `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Id          string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name        string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	StorageOpts []string `protobuf:"bytes,4,rep,name=storage_opts,json=storageOpts,proto3" json:"storage_opts,omitempty"`
}

func (x *ContainerPrepareRequest) Reset() {
	*x = ContainerPrepareRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerPrepareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerPrepareRequest) ProtoMessage() {}

func (x *ContainerPrepareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerPrepareRequest.ProtoReflect.Descriptor instead.
func (*ContainerPrepareRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{24}
}

func (x *ContainerPrepareRequest) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *ContainerPrepareRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ContainerPrepareRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ContainerPrepareRequest) GetStorageOpts() []string {
	if x != nil {
		return x.StorageOpts
	}
	return nil
}

type ContainerPrepareResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MountPoint string `protobuf:"bytes,1,opt,name=mount_point,json=mountPoint,proto3" json:"mount_point,omitempty"`
	ImageConf  string `protobuf:"bytes,2,opt,name=image_conf,json=imageConf,proto3" json:"image_conf,omitempty"`
	Errmsg     string `protobuf:"bytes,3,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc         uint32 `protobuf:"varint,4,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ContainerPrepareResponse) Reset() {
	*x = ContainerPrepareResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContainerPrepareResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerPrepareResponse) ProtoMessage() {}

func (x *ContainerPrepareResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerPrepareResponse.ProtoReflect.Descriptor instead.
func (*ContainerPrepareResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{25}
}

func (x *ContainerPrepareResponse) GetMountPoint() string {
	if x != nil {
		return x.MountPoint
	}
	return ""
}

func (x *ContainerPrepareResponse) GetImageConf() string {
	if x != nil {
		return x.ImageConf
	}
	return ""
}

func (x *ContainerPrepareResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ContainerPrepareResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ListContainersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ListContainersRequest) Reset() {
	*x = ListContainersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListContainersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListContainersRequest) ProtoMessage() {}

func (x *ListContainersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListContainersRequest.ProtoReflect.Descriptor instead.
func (*ListContainersRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{26}
}

type ListContainersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Containers map[string]bool `protobuf:"bytes,1,rep,name=containers,proto3" json:"containers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Errmsg     string          `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc         uint32          `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ListContainersResponse) Reset() {
	*x = ListContainersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListContainersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListContainersResponse) ProtoMessage() {}

func (x *ListContainersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListContainersResponse.ProtoReflect.Descriptor instead.
func (*ListContainersResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{27}
}

func (x *ListContainersResponse) GetContainers() map[string]bool {
	if x != nil {
		return x.Containers
	}
	return nil
}

func (x *ListContainersResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ListContainersResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

// DNSConfig specifies the DNS servers and search domains of a sandbox.
type DNSConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of DNS servers of the cluster.
	Servers []string `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	// List of DNS search domains of the cluster.
	Searches []string `protobuf:"bytes,2,rep,name=searches,proto3" json:"searches,omitempty"`
	// List of DNS options. See https://linux.die.net/man/5/resolv.conf
	// for all available options.
	Options []string `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
}

func (x *DNSConfig) Reset() {
	*x = DNSConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DNSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSConfig) ProtoMessage() {}

func (x *DNSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.
func (*DNSConfig) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{28}
}

func (x *DNSConfig) GetServers() []string {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *DNSConfig) GetSearches() []string {
	if x != nil {
		return x.Searches
	}
	return nil
}

func (x *DNSConfig) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

// PortMapping specifies the port mapping configurations of a sandbox.
type PortMapping struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Protocol of the port mapping.
	Protocol Protocol `protobuf:"varint,1,opt,name=protocol,proto3,enum=isula.Protocol" json:"protocol,omitempty"`
	// Port number within the container. Default: 0 (not specified).
	ContainerPort int32 `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	// Port number on the host. Default: 0 (not specified).
	HostPort int32 `protobuf:"varint,3,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	// Host IP.
	HostIp string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
}

func (x *PortMapping) Reset() {
	*x = PortMapping{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PortMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortMapping) ProtoMessage() {}

func (x *PortMapping) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortMapping.ProtoReflect.Descriptor instead.
func (*PortMapping) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{29}
}

func (x *PortMapping) GetProtocol() Protocol {
	if x != nil {
		return x.Protocol
	}
	return Protocol_TCP
}

func (x *PortMapping) GetContainerPort() int32 {
	if x != nil {
		return x.ContainerPort
	}
	return 0
}

func (x *PortMapping) GetHostPort() int32 {
	if x != nil {
		return x.HostPort
	}
	return 0
}

func (x *PortMapping) GetHostIp() string {
	if x != nil {
		return x.HostIp
	}
	return ""
}

// Mount specifies a host volume to mount into a container.
type Mount struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Path of the mount within the container.
	ContainerPath string `protobuf:"bytes,1,opt,name=container_path,json=containerPath,proto3" json:"container_path,omitempty"`
	// Path of the mount on the host.
	HostPath string `protobuf:"bytes,2,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty"`
	// If set, the mount is read-only.
	Readonly bool `protobuf:"varint,3,opt,name=readonly,proto3" json:"readonly,omitempty"`
	// If set, the mount needs SELinux relabeling.
	SelinuxRelabel bool `protobuf:"varint,4,opt,name=selinux_relabel,json=selinuxRelabel,proto3" json:"selinux_relabel,omitempty"`
	// Requested propagation mode.
	Propagation MountPropagation `protobuf:"varint,5,opt,name=propagation,proto3,enum=isula.MountPropagation" json:"propagation,omitempty"`
}

func (x *Mount) Reset() {
	*x = Mount{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Mount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Mount) ProtoMessage() {}

func (x *Mount) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Mount.ProtoReflect.Descriptor instead.
func (*Mount) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{30}
}

func (x *Mount) GetContainerPath() string {
	if x != nil {
		return x.ContainerPath
	}
	return ""
}

func (x *Mount) GetHostPath() string {
	if x != nil {
		return x.HostPath
	}
	return ""
}

func (x *Mount) GetReadonly() bool {
	if x != nil {
		return x.Readonly
	}
	return false
}

func (x *Mount) GetSelinuxRelabel() bool {
	if x != nil {
		return x.SelinuxRelabel
	}
	return false
}

func (x *Mount) GetPropagation() MountPropagation {
	if x != nil {
		return x.Propagation
	}
	return MountPropagation_PROPAGATION_PRIVATE
}

// NamespaceOption provides options for Linux namespaces.
type NamespaceOption struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If set, use the host's network namespace.
	HostNetwork bool `protobuf:"varint,1,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	// If set, use the host's PID namespace.
	HostPid bool `protobuf:"varint,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// If set, use the host's IPC namespace.
	HostIpc bool `protobuf:"varint,3,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
}

func (x *NamespaceOption) Reset() {
	*x = NamespaceOption{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NamespaceOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NamespaceOption) ProtoMessage() {}

func (x *NamespaceOption) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NamespaceOption.ProtoReflect.Descriptor instead.
func (*NamespaceOption) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{31}
}

func (x *NamespaceOption) GetHostNetwork() bool {
	if x != nil {
		return x.HostNetwork
	}
	return false
}

func (x *NamespaceOption) GetHostPid() bool {
	if x != nil {
		return x.HostPid
	}
	return false
}

func (x *NamespaceOption) GetHostIpc() bool {
	if x != nil {
		return x.HostIpc
	}
	return false
}

// Int64Value is the wrapper of int64.
type Int64Value struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value.
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Int64Value) Reset() {
	*x = Int64Value{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Int64Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Int64Value) ProtoMessage() {}

func (x *Int64Value) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Int64Value.ProtoReflect.Descriptor instead.
func (*Int64Value) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{32}
}

func (x *Int64Value) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// SELinuxOption are the labels to be applied to the container.
type SELinuxOption struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User  string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Role  string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	Type  string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Level string `protobuf:"bytes,4,opt,name=level,proto3" json:"level,omitempty"`
}

func (x *SELinuxOption) Reset() {
	*x = SELinuxOption{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SELinuxOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SELinuxOption) ProtoMessage() {}

func (x *SELinuxOption) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SELinuxOption.ProtoReflect.Descriptor instead.
func (*SELinuxOption) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{33}
}

func (x *SELinuxOption) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *SELinuxOption) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *SELinuxOption) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *SELinuxOption) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

// LinuxSandboxSecurityContext holds linux security configuration that will be
// applied to a sandbox. Note that:
// 1) It does not apply to containers in the pods.
// 2) It may not be applicable to a PodSandbox which does not contain any running
//    process.
type LinuxSandboxSecurityContext struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Configurations for the sandbox's namespaces.
	// This will be used only if the PodSandbox uses namespace for isolation.
	NamespaceOptions *NamespaceOption `protobuf:"bytes,1,opt,name=namespace_options,json=namespaceOptions,proto3" json:"namespace_options,omitempty"`
	// Optional SELinux context to be applied.
	SelinuxOptions *SELinuxOption `protobuf:"bytes,2,opt,name=selinux_options,json=selinuxOptions,proto3" json:"selinux_options,omitempty"`
	// UID to run sandbox processes as, when applicable.
	RunAsUser *Int64Value `protobuf:"bytes,3,opt,name=run_as_user,json=runAsUser,proto3" json:"run_as_user,omitempty"`
	// If set, the root filesystem of the sandbox is read-only.
	ReadonlyRootfs bool `protobuf:"varint,4,opt,name=readonly_rootfs,json=readonlyRootfs,proto3" json:"readonly_rootfs,omitempty"`
	// List of groups applied to the first process run in the sandbox, in
	// addition to the sandbox's primary GID.
	SupplementalGroups []int64 `protobuf:"varint,5,rep,packed,name=supplemental_groups,json=supplementalGroups,proto3" json:"supplemental_groups,omitempty"`
	// Indicates whether the sandbox will be asked to run a privileged
	// container. If a privileged container is to be executed within it, this
	// MUST be true.
	// This allows a sandbox to take additional security precautions if no
	// privileged containers are expected to be run.
	Privileged bool `protobuf:"varint,6,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Seccomp profile for the sandbox, candidate values are:
	// * docker/default: the default profile for the docker container runtime
	// * unconfined: unconfined profile, ie, no seccomp sandboxing
	// * localhost/<full-path-to-profile>: the profile installed on the node.
	//   <full-path-to-profile> is the full path of the profile.
	// Default: "", which is identical with unconfined.
	SeccompProfilePath string `protobuf:"bytes,7,opt,name=seccomp_profile_path,json=seccompProfilePath,proto3" json:"seccomp_profile_path,omitempty"`
}

func (x *LinuxSandboxSecurityContext) Reset() {
	*x = LinuxSandboxSecurityContext{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinuxSandboxSecurityContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinuxSandboxSecurityContext) ProtoMessage() {}

func (x *LinuxSandboxSecurityContext) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinuxSandboxSecurityContext.ProtoReflect.Descriptor instead.
func (*LinuxSandboxSecurityContext) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{34}
}

func (x *LinuxSandboxSecurityContext) GetNamespaceOptions() *NamespaceOption {
	if x != nil {
		return x.NamespaceOptions
	}
	return nil
}

func (x *LinuxSandboxSecurityContext) GetSelinuxOptions() *SELinuxOption {
	if x != nil {
		return x.SelinuxOptions
	}
	return nil
}

func (x *LinuxSandboxSecurityContext) GetRunAsUser() *Int64Value {
	if x != nil {
		return x.RunAsUser
	}
	return nil
}

func (x *LinuxSandboxSecurityContext) GetReadonlyRootfs() bool {
	if x != nil {
		return x.ReadonlyRootfs
	}
	return false
}

func (x *LinuxSandboxSecurityContext) GetSupplementalGroups() []int64 {
	if x != nil {
		return x.SupplementalGroups
	}
	return nil
}

func (x *LinuxSandboxSecurityContext) GetPrivileged() bool {
	if x != nil {
		return x.Privileged
	}
	return false
}

func (x *LinuxSandboxSecurityContext) GetSeccompProfilePath() string {
	if x != nil {
		return x.SeccompProfilePath
	}
	return ""
}

// LinuxPodSandboxConfig holds platform-specific configurations for Linux
// host platforms and Linux-based containers.
type LinuxPodSandboxConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parent cgroup of the PodSandbox.
	// The cgroupfs style syntax will be used, but the container runtime can
	// convert it to systemd semantics if needed.
	CgroupParent string `protobuf:"bytes,1,opt,name=cgroup_parent,json=cgroupParent,proto3" json:"cgroup_parent,omitempty"`
	// LinuxSandboxSecurityContext holds sandbox security attributes.
	SecurityContext *LinuxSandboxSecurityContext `protobuf:"bytes,2,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty"`
	// Sysctls holds linux sysctls config for the sandbox.
	Sysctls map[string]string `protobuf:"bytes,3,rep,name=sysctls,proto3" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *LinuxPodSandboxConfig) Reset() {
	*x = LinuxPodSandboxConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinuxPodSandboxConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinuxPodSandboxConfig) ProtoMessage() {}

func (x *LinuxPodSandboxConfig) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinuxPodSandboxConfig.ProtoReflect.Descriptor instead.
func (*LinuxPodSandboxConfig) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{35}
}

func (x *LinuxPodSandboxConfig) GetCgroupParent() string {
	if x != nil {
		return x.CgroupParent
	}
	return ""
}

func (x *LinuxPodSandboxConfig) GetSecurityContext() *LinuxSandboxSecurityContext {
	if x != nil {
		return x.SecurityContext
	}
	return nil
}

func (x *LinuxPodSandboxConfig) GetSysctls() map[string]string {
	if x != nil {
		return x.Sysctls
	}
	return nil
}

// PodSandboxMetadata holds all necessary information for building the sandbox name.
// The container runtime is encouraged to expose the metadata associated with the
// PodSandbox in its user interface for better user experience. For example,
// the runtime can construct a unique PodSandboxName based on the metadata.
type PodSandboxMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Pod name of the sandbox. Same as the pod name in the PodSpec.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Pod UID of the sandbox. Same as the pod UID in the PodSpec.
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// Pod namespace of the sandbox. Same as the pod namespace in the PodSpec.
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Attempt number of creating the sandbox. Default: 0.
	Attempt uint32 `protobuf:"varint,4,opt,name=attempt,proto3" json:"attempt,omitempty"`
}

func (x *PodSandboxMetadata) Reset() {
	*x = PodSandboxMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PodSandboxMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PodSandboxMetadata) ProtoMessage() {}

func (x *PodSandboxMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PodSandboxMetadata.ProtoReflect.Descriptor instead.
func (*PodSandboxMetadata) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{36}
}

func (x *PodSandboxMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PodSandboxMetadata) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *PodSandboxMetadata) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *PodSandboxMetadata) GetAttempt() uint32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

// PodSandboxConfig holds all the required and optional fields for creating a
// sandbox.
type PodSandboxConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Metadata of the sandbox. This information will uniquely identify the
	// sandbox, and the runtime should leverage this to ensure correct
	// operation. The runtime may also use this information to improve UX, such
	// as by constructing a readable name.
	Metadata *PodSandboxMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Hostname of the sandbox.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Path to the directory on the host in which container log files are
	// stored.
	// By default the log of a container going into the LogDirectory will be
	// hooked up to STDOUT and STDERR. However, the LogDirectory may contain
	// binary log files with structured logging data from the individual
	// containers. For example, the files might be newline separated JSON
	// structured logs, systemd-journald journal files, gRPC trace files, etc.
	// E.g.,
	//     PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`
	//     ContainerConfig.LogPath = `containerName_Instance#.log`
	//
	// WARNING: Log management and how kubelet should interface with the
	// container logs are under active discussion in
	// https://issues.k8s.io/24677. There *may* be future change of direction
	// for logging as the discussion carries on.
	LogDirectory string `protobuf:"bytes,3,opt,name=log_directory,json=logDirectory,proto3" json:"log_directory,omitempty"`
	// DNS config for the sandbox.
	DnsConfig *DNSConfig `protobuf:"bytes,4,opt,name=dns_config,json=dnsConfig,proto3" json:"dns_config,omitempty"`
	// Port mappings for the sandbox.
	PortMappings []*PortMapping `protobuf:"bytes,5,rep,name=port_mappings,json=portMappings,proto3" json:"port_mappings,omitempty"`
	// Key-value pairs that may be used to scope and select individual resources.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Unstructured key-value map that may be set by the kubelet to store and
	// retrieve arbitrary metadata. This will include any annotations set on a
	// pod through the Kubernetes API.
	//
	// Annotations MUST NOT be altered by the runtime; the annotations stored
	// here MUST be returned in the PodSandboxStatus associated with the pod
	// this PodSandboxConfig creates.
	//
	// In general, in order to preserve a well-defined interface between the
	// kubelet and the container runtime, annotations SHOULD NOT influence
	// runtime behaviour.
	//
	// Annotations can also be useful for runtime authors to experiment with
	// new features that are opaque to the Kubernetes APIs (both user-facing
	// and the CRI). Whenever possible, however, runtime authors SHOULD
	// consider proposing new typed fields for any new features instead.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Optional configurations specific to Linux hosts.
	Linux *LinuxPodSandboxConfig `protobuf:"bytes,8,opt,name=linux,proto3" json:"linux,omitempty"`
}

func (x *PodSandboxConfig) Reset() {
	*x = PodSandboxConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PodSandboxConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PodSandboxConfig) ProtoMessage() {}

func (x *PodSandboxConfig) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PodSandboxConfig.ProtoReflect.Descriptor instead.
func (*PodSandboxConfig) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{37}
}

func (x *PodSandboxConfig) GetMetadata() *PodSandboxMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PodSandboxConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *PodSandboxConfig) GetLogDirectory() string {
	if x != nil {
		return x.LogDirectory
	}
	return ""
}

func (x *PodSandboxConfig) GetDnsConfig() *DNSConfig {
	if x != nil {
		return x.DnsConfig
	}
	return nil
}

func (x *PodSandboxConfig) GetPortMappings() []*PortMapping {
	if x != nil {
		return x.PortMappings
	}
	return nil
}

func (x *PodSandboxConfig) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *PodSandboxConfig) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *PodSandboxConfig) GetLinux() *LinuxPodSandboxConfig {
	if x != nil {
		return x.Linux
	}
	return nil
}

// ImageSpec is an internal representation of an image.  Currently, it wraps the
// value of a Container's Image field (e.g. imageID or imageDigest), but in the
// future it will include more detailed information about the different image types.
type ImageSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Image string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *ImageSpec) Reset() {
	*x = ImageSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSpec) ProtoMessage() {}

func (x *ImageSpec) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSpec.ProtoReflect.Descriptor instead.
func (*ImageSpec) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{38}
}

func (x *ImageSpec) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

type ImageFilter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Spec of the image.
	Image *ImageSpec `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *ImageFilter) Reset() {
	*x = ImageFilter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageFilter) ProtoMessage() {}

func (x *ImageFilter) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageFilter.ProtoReflect.Descriptor instead.
func (*ImageFilter) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{39}
}

func (x *ImageFilter) GetImage() *ImageSpec {
	if x != nil {
		return x.Image
	}
	return nil
}

type ListImagesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Filter to list images.
	Filter *ImageFilter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Check  bool         `protobuf:"varint,2,opt,name=check,proto3" json:"check,omitempty"`
}

func (x *ListImagesRequest) Reset() {
	*x = ListImagesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListImagesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListImagesRequest) ProtoMessage() {}

func (x *ListImagesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListImagesRequest.ProtoReflect.Descriptor instead.
func (*ListImagesRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{40}
}

func (x *ListImagesRequest) GetFilter() *ImageFilter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *ListImagesRequest) GetCheck() bool {
	if x != nil {
		return x.Check
	}
	return false
}

type HealthCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Test            []string `protobuf:"bytes,1,rep,name=test,proto3" json:"test,omitempty"`
	Interval        int64    `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Timeout         int64    `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	StartPeriod     int64    `protobuf:"varint,4,opt,name=start_period,json=startPeriod,proto3" json:"start_period,omitempty"`
	Retries         int32    `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
	ExitOnUnhealthy bool     `protobuf:"varint,6,opt,name=exit_on_unhealthy,json=exitOnUnhealthy,proto3" json:"exit_on_unhealthy,omitempty"`
}

func (x *HealthCheck) Reset() {
	*x = HealthCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck) ProtoMessage() {}

func (x *HealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{41}
}

func (x *HealthCheck) GetTest() []string {
	if x != nil {
		return x.Test
	}
	return nil
}

func (x *HealthCheck) GetInterval() int64 {
	if x != nil {
		return x.Interval
	}
	return 0
}

func (x *HealthCheck) GetTimeout() int64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *HealthCheck) GetStartPeriod() int64 {
	if x != nil {
		return x.StartPeriod
	}
	return 0
}

func (x *HealthCheck) GetRetries() int32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *HealthCheck) GetExitOnUnhealthy() bool {
	if x != nil {
		return x.ExitOnUnhealthy
	}
	return false
}

// Basic information about a container image.
type Image struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ID of the image.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Other names by which this image is known.
	RepoTags []string `protobuf:"bytes,2,rep,name=repo_tags,json=repoTags,proto3" json:"repo_tags,omitempty"`
	// Digests by which this image is known.
	RepoDigests []string `protobuf:"bytes,3,rep,name=repo_digests,json=repoDigests,proto3" json:"repo_digests,omitempty"`
	// Size of the image in bytes. Must be > 0.
	Size uint64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// UID that will run the command(s). This is used as a default if no user is
	// specified when creating the container. UID and the following user name
	// are mutually exclusive.
	Uid *Int64Value `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty"`
	// User name that will run the command(s). This is used if UID is not set
	// and no user is specified when creating container.
	Username string `protobuf:"bytes,6,opt,name=username,proto3" json:"username,omitempty"`
	// Create time of image
	Created string `protobuf:"bytes,7,opt,name=created,proto3" json:"created,omitempty"`
	// Load time of image
	Loaded string `protobuf:"bytes,8,opt,name=loaded,proto3" json:"loaded,omitempty"`
	// oci image spec
	Spec *ImageSpec `protobuf:"bytes,9,opt,name=spec,proto3" json:"spec,omitempty"`
	// Health check
	Healthcheck *HealthCheck `protobuf:"bytes,10,opt,name=healthcheck,proto3" json:"healthcheck,omitempty"`
}

func (x *Image) Reset() {
	*x = Image{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Image) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Image) ProtoMessage() {}

func (x *Image) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Image.ProtoReflect.Descriptor instead.
func (*Image) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{42}
}

func (x *Image) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Image) GetRepoTags() []string {
	if x != nil {
		return x.RepoTags
	}
	return nil
}

func (x *Image) GetRepoDigests() []string {
	if x != nil {
		return x.RepoDigests
	}
	return nil
}

func (x *Image) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *Image) GetUid() *Int64Value {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Image) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *Image) GetCreated() string {
	if x != nil {
		return x.Created
	}
	return ""
}

func (x *Image) GetLoaded() string {
	if x != nil {
		return x.Loaded
	}
	return ""
}

func (x *Image) GetSpec() *ImageSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Image) GetHealthcheck() *HealthCheck {
	if x != nil {
		return x.Healthcheck
	}
	return nil
}

type ListImagesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of images.
	Images []*Image `protobuf:"bytes,1,rep,name=images,proto3" json:"images,omitempty"`
	Errmsg string   `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32   `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ListImagesResponse) Reset() {
	*x = ListImagesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListImagesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListImagesResponse) ProtoMessage() {}

func (x *ListImagesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListImagesResponse.ProtoReflect.Descriptor instead.
func (*ListImagesResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{43}
}

func (x *ListImagesResponse) GetImages() []*Image {
	if x != nil {
		return x.Images
	}
	return nil
}

func (x *ListImagesResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ListImagesResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ImageStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Spec of the image.
	Image *ImageSpec `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Verbose indicates whether to return extra information about the image.
	Verbose bool `protobuf:"varint,2,opt,name=verbose,proto3" json:"verbose,omitempty"`
}

func (x *ImageStatusRequest) Reset() {
	*x = ImageStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageStatusRequest) ProtoMessage() {}

func (x *ImageStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageStatusRequest.ProtoReflect.Descriptor instead.
func (*ImageStatusRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{44}
}

func (x *ImageStatusRequest) GetImage() *ImageSpec {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *ImageStatusRequest) GetVerbose() bool {
	if x != nil {
		return x.Verbose
	}
	return false
}

type ImageStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Status of the image.
	Image *Image `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Info is extra information of the Image. The key could be abitrary string, and
	// value should be in json format. The information could include anything useful
	// for debug, e.g. image config for oci image based container runtime.
	// It should only be returned non-empty when Verbose is true.
	Info   map[string]string `protobuf:"bytes,2,rep,name=info,proto3" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Errmsg string            `protobuf:"bytes,3,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32            `protobuf:"varint,4,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ImageStatusResponse) Reset() {
	*x = ImageStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageStatusResponse) ProtoMessage() {}

func (x *ImageStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageStatusResponse.ProtoReflect.Descriptor instead.
func (*ImageStatusResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{45}
}

func (x *ImageStatusResponse) GetImage() *Image {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *ImageStatusResponse) GetInfo() map[string]string {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *ImageStatusResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ImageStatusResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ImageInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Image *ImageSpec `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *ImageInfoRequest) Reset() {
	*x = ImageInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageInfoRequest) ProtoMessage() {}

func (x *ImageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageInfoRequest.ProtoReflect.Descriptor instead.
func (*ImageInfoRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{46}
}

func (x *ImageInfoRequest) GetImage() *ImageSpec {
	if x != nil {
		return x.Image
	}
	return nil
}

type ImageInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Spec   string `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Errmsg string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ImageInfoResponse) Reset() {
	*x = ImageInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[47]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageInfoResponse) ProtoMessage() {}

func (x *ImageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[47]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageInfoResponse.ProtoReflect.Descriptor instead.
func (*ImageInfoResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{47}
}

func (x *ImageInfoResponse) GetSpec() string {
	if x != nil {
		return x.Spec
	}
	return ""
}

func (x *ImageInfoResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ImageInfoResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

// AuthConfig contains authorization information for connecting to a registry.
type AuthConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Username      string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Auth          string `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
	ServerAddress string `protobuf:"bytes,4,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	// IdentityToken is used to authenticate the user and get
	// an access token for the registry.
	IdentityToken string `protobuf:"bytes,5,opt,name=identity_token,json=identityToken,proto3" json:"identity_token,omitempty"`
	// RegistryToken is a bearer token to be sent to a registry
	RegistryToken string `protobuf:"bytes,6,opt,name=registry_token,json=registryToken,proto3" json:"registry_token,omitempty"`
}

func (x *AuthConfig) Reset() {
	*x = AuthConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[48]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthConfig) ProtoMessage() {}

func (x *AuthConfig) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[48]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthConfig.ProtoReflect.Descriptor instead.
func (*AuthConfig) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{48}
}

func (x *AuthConfig) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *AuthConfig) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *AuthConfig) GetAuth() string {
	if x != nil {
		return x.Auth
	}
	return ""
}

func (x *AuthConfig) GetServerAddress() string {
	if x != nil {
		return x.ServerAddress
	}
	return ""
}

func (x *AuthConfig) GetIdentityToken() string {
	if x != nil {
		return x.IdentityToken
	}
	return ""
}

func (x *AuthConfig) GetRegistryToken() string {
	if x != nil {
		return x.RegistryToken
	}
	return ""
}

type PullImageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Spec of the image.
	Image *ImageSpec `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Authentication configuration for pulling the image.
	Auth *AuthConfig `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth,omitempty"`
	// Config of the PodSandbox, which is used to pull image in PodSandbox context.
	SandboxConfig *PodSandboxConfig `protobuf:"bytes,3,opt,name=sandbox_config,json=sandboxConfig,proto3" json:"sandbox_config,omitempty"`
}

func (x *PullImageRequest) Reset() {
	*x = PullImageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[49]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PullImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PullImageRequest) ProtoMessage() {}

func (x *PullImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[49]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PullImageRequest.ProtoReflect.Descriptor instead.
func (*PullImageRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{49}
}

func (x *PullImageRequest) GetImage() *ImageSpec {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *PullImageRequest) GetAuth() *AuthConfig {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *PullImageRequest) GetSandboxConfig() *PodSandboxConfig {
	if x != nil {
		return x.SandboxConfig
	}
	return nil
}

type PullImageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Reference to the image in use. For most runtimes, this should be an
	// image ID or digest.
	ImageRef string `protobuf:"bytes,1,opt,name=image_ref,json=imageRef,proto3" json:"image_ref,omitempty"`
	Errmsg   string `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc       uint32 `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *PullImageResponse) Reset() {
	*x = PullImageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[50]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PullImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PullImageResponse) ProtoMessage() {}

func (x *PullImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[50]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PullImageResponse.ProtoReflect.Descriptor instead.
func (*PullImageResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{50}
}

func (x *PullImageResponse) GetImageRef() string {
	if x != nil {
		return x.ImageRef
	}
	return ""
}

func (x *PullImageResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *PullImageResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type RemoveImageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Spec of the image to remove.
	Image *ImageSpec `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Force bool       `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
}

func (x *RemoveImageRequest) Reset() {
	*x = RemoveImageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[51]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveImageRequest) ProtoMessage() {}

func (x *RemoveImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[51]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveImageRequest.ProtoReflect.Descriptor instead.
func (*RemoveImageRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{51}
}

func (x *RemoveImageRequest) GetImage() *ImageSpec {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *RemoveImageRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type RemoveImageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *RemoveImageResponse) Reset() {
	*x = RemoveImageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[52]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveImageResponse) ProtoMessage() {}

func (x *RemoveImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[52]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveImageResponse.ProtoReflect.Descriptor instead.
func (*RemoveImageResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{52}
}

func (x *RemoveImageResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *RemoveImageResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type ImageFsInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ImageFsInfoRequest) Reset() {
	*x = ImageFsInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[53]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageFsInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageFsInfoRequest) ProtoMessage() {}

func (x *ImageFsInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[53]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageFsInfoRequest.ProtoReflect.Descriptor instead.
func (*ImageFsInfoRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{53}
}

// UInt64Value is the wrapper of uint64.
type UInt64Value struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value.
	Value uint64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *UInt64Value) Reset() {
	*x = UInt64Value{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[54]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UInt64Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UInt64Value) ProtoMessage() {}

func (x *UInt64Value) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[54]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UInt64Value.ProtoReflect.Descriptor instead.
func (*UInt64Value) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{54}
}

func (x *UInt64Value) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// StorageIdentifier uniquely identify the storage..
type StorageIdentifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// UUID of the device.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (x *StorageIdentifier) Reset() {
	*x = StorageIdentifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[55]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageIdentifier) ProtoMessage() {}

func (x *StorageIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[55]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageIdentifier.ProtoReflect.Descriptor instead.
func (*StorageIdentifier) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{55}
}

func (x *StorageIdentifier) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

// FilesystemUsage provides the filesystem usage information.
type FilesystemUsage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Timestamp in nanoseconds at which the information were collected. Must be > 0.
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The underlying storage of the filesystem.
	StorageId *StorageIdentifier `protobuf:"bytes,2,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// UsedBytes represents the bytes used for images on the filesystem.
	// This may differ from the total bytes used on the filesystem and may not
	// equal CapacityBytes - AvailableBytes.
	UsedBytes *UInt64Value `protobuf:"bytes,3,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
	// InodesUsed represents the inodes used by the images.
	// This may not equal InodesCapacity - InodesAvailable because the underlying
	// filesystem may also be used for purposes other than storing images.
	InodesUsed *UInt64Value `protobuf:"bytes,4,opt,name=inodes_used,json=inodesUsed,proto3" json:"inodes_used,omitempty"`
}

func (x *FilesystemUsage) Reset() {
	*x = FilesystemUsage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[56]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilesystemUsage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilesystemUsage) ProtoMessage() {}

func (x *FilesystemUsage) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[56]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilesystemUsage.ProtoReflect.Descriptor instead.
func (*FilesystemUsage) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{56}
}

func (x *FilesystemUsage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *FilesystemUsage) GetStorageId() *StorageIdentifier {
	if x != nil {
		return x.StorageId
	}
	return nil
}

func (x *FilesystemUsage) GetUsedBytes() *UInt64Value {
	if x != nil {
		return x.UsedBytes
	}
	return nil
}

func (x *FilesystemUsage) GetInodesUsed() *UInt64Value {
	if x != nil {
		return x.InodesUsed
	}
	return nil
}

type ImageFsInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Information of image filesystem(s).
	ImageFilesystems []*FilesystemUsage `protobuf:"bytes,1,rep,name=image_filesystems,json=imageFilesystems,proto3" json:"image_filesystems,omitempty"`
	Errmsg           string             `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc               uint32             `protobuf:"varint,3,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *ImageFsInfoResponse) Reset() {
	*x = ImageFsInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[57]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageFsInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageFsInfoResponse) ProtoMessage() {}

func (x *ImageFsInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[57]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageFsInfoResponse.ProtoReflect.Descriptor instead.
func (*ImageFsInfoResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{57}
}

func (x *ImageFsInfoResponse) GetImageFilesystems() []*FilesystemUsage {
	if x != nil {
		return x.ImageFilesystems
	}
	return nil
}

func (x *ImageFsInfoResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *ImageFsInfoResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

type TagImageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SrcName  *ImageSpec `protobuf:"bytes,1,opt,name=srcName,proto3" json:"srcName,omitempty"`
	DestName *ImageSpec `protobuf:"bytes,2,opt,name=destName,proto3" json:"destName,omitempty"`
}

func (x *TagImageRequest) Reset() {
	*x = TagImageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[58]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TagImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TagImageRequest) ProtoMessage() {}

func (x *TagImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[58]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TagImageRequest.ProtoReflect.Descriptor instead.
func (*TagImageRequest) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{58}
}

func (x *TagImageRequest) GetSrcName() *ImageSpec {
	if x != nil {
		return x.SrcName
	}
	return nil
}

func (x *TagImageRequest) GetDestName() *ImageSpec {
	if x != nil {
		return x.DestName
	}
	return nil
}

type TagImageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Errmsg string `protobuf:"bytes,1,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	Cc     uint32 `protobuf:"varint,2,opt,name=cc,proto3" json:"cc,omitempty"`
}

func (x *TagImageResponse) Reset() {
	*x = TagImageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_isula_image_proto_msgTypes[59]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TagImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TagImageResponse) ProtoMessage() {}

func (x *TagImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_isula_image_proto_msgTypes[59]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TagImageResponse.ProtoReflect.Descriptor instead.
func (*TagImageResponse) Descriptor() ([]byte, []int) {
	return file_isula_image_proto_rawDescGZIP(), []int{59}
}

func (x *TagImageResponse) GetErrmsg() string {
	if x != nil {
		return x.Errmsg
	}
	return ""
}

func (x *TagImageResponse) GetCc() uint32 {
	if x != nil {
		return x.Cc
	}
	return 0
}

var File_isula_image_proto protoreflect.FileDescriptor

var file_isula_image_proto_rawDesc = []byte{
	0x0a, 0x11, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x05, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x22, 0x14, 0x0a, 0x12, 0x48, 0x65,
	0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x22, 0x3d, 0x0a, 0x13, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73,
	0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12,
	0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22,
	0x5e, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x16, 0x0a, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22,
	0x37, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x27, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x6f,
	0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x72,
	0x76, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x72, 0x22, 0x38, 0x0a, 0x0e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63,
	0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x85, 0x01, 0x0a, 0x16,
	0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x64, 0x12,
	0x16, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x75, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x69, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x67, 0x69, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6f, 0x66, 0x66,
	0x73, 0x65, 0x74, 0x22, 0x41, 0x0a, 0x17, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
	0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16,
	0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x38, 0x0a, 0x10, 0x4c, 0x6f, 0x61, 0x64, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x69,
	0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x10,
	0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67,
	0x22, 0x54, 0x0a, 0x12, 0x4c, 0x6f, 0x61, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x6f, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x6d, 0x73, 0x67,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x6d, 0x73, 0x67, 0x12, 0x16,
	0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x35, 0x0a, 0x0d, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x74,
	0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67, 0x22, 0x49, 0x0a,
	0x0f, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x6f, 0x73, 0x65,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x1a, 0x0a, 0x18, 0x47, 0x72, 0x61, 0x70,
	0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a, 0x19, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69,
	0x76, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72,
	0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73,
	0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63,
	0x63, 0x22, 0x35, 0x0a, 0x1a, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x17, 0x0a, 0x07, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x64, 0x22, 0xe4, 0x01, 0x0a, 0x1b, 0x47, 0x72, 0x61,
	0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x6d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72,
	0x72, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d,
	0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02,
	0x63, 0x63, 0x1a, 0x3b, 0x0a, 0x0d, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22,
	0x32, 0x0a, 0x17, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x73, 0x55, 0x73,
	0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x61,
	0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x61, 0x6d,
	0x65, 0x49, 0x64, 0x22, 0x58, 0x0a, 0x18, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
	0x46, 0x73, 0x55, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x14, 0x0a, 0x05, 0x75, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x75, 0x73, 0x61, 0x67, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a,
	0x02, 0x63, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x47, 0x0a,
	0x16, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x55, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x61, 0x6d, 0x65, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x64,
	0x12, 0x14, 0x0a, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x22, 0x41, 0x0a, 0x17, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69,
	0x6e, 0x65, 0x72, 0x55, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x30, 0x0a, 0x15, 0x43, 0x6f, 0x6e,
	0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x64, 0x22, 0x40, 0x0a, 0x16, 0x43,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a,
	0x02, 0x63, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x31, 0x0a,
	0x16, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x61, 0x6d, 0x65, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x64,
	0x22, 0x41, 0x0a, 0x17, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x6d,
	0x6f, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65,
	0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72,
	0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x02, 0x63, 0x63, 0x22, 0x76, 0x0a, 0x17, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
	0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14,
	0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x5f, 0x6f, 0x70, 0x74, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b,
	0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4f, 0x70, 0x74, 0x73, 0x22, 0x82, 0x01, 0x0a, 0x18,
	0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d,
	0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67,
	0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63,
	0x22, 0x17, 0x0a, 0x15, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xce, 0x01, 0x0a, 0x16, 0x4c, 0x69,
	0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4d, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61,
	0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
	0x65, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63,
	0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x1a, 0x3d, 0x0a, 0x0f, 0x43,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x5b, 0x0a, 0x09, 0x44, 0x4e,
	0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x73, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x08, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,
	0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x97, 0x01, 0x0a, 0x0b, 0x50, 0x6f, 0x72, 0x74,
	0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x2b, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0d, 0x63, 0x6f,
	0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x68,
	0x6f, 0x73, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08,
	0x68, 0x6f, 0x73, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x68, 0x6f, 0x73, 0x74,
	0x5f, 0x69, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x68, 0x6f, 0x73, 0x74, 0x49,
	0x70, 0x22, 0xcb, 0x01, 0x0a, 0x05, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x50, 0x61,
	0x74, 0x68, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x12,
	0x1a, 0x0a, 0x08, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x12, 0x27, 0x0a, 0x0f, 0x73,
	0x65, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x5f, 0x72, 0x65, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x52, 0x65, 0x6c,
	0x61, 0x62, 0x65, 0x6c, 0x12, 0x39, 0x0a, 0x0b, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,
	0x6a, 0x0a, 0x0f, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x68, 0x6f, 0x73, 0x74, 0x4e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x19, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x70, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x68, 0x6f, 0x73, 0x74, 0x50, 0x69, 0x64,
	0x12, 0x19, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x69, 0x70, 0x63, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x68, 0x6f, 0x73, 0x74, 0x49, 0x70, 0x63, 0x22, 0x22, 0x0a, 0x0a, 0x49,
	0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22,
	0x61, 0x0a, 0x0d, 0x53, 0x45, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x75, 0x73, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x65, 0x76,
	0x65, 0x6c, 0x22, 0x80, 0x03, 0x0a, 0x1b, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x53, 0x61, 0x6e, 0x64,
	0x62, 0x6f, 0x78, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x65,
	0x78, 0x74, 0x12, 0x43, 0x0a, 0x11, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f,
	0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x0f, 0x73, 0x65, 0x6c, 0x69, 0x6e,
	0x75, 0x78, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x14, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x53, 0x45, 0x4c, 0x69, 0x6e, 0x75, 0x78,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0e, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x31, 0x0a, 0x0b, 0x72, 0x75, 0x6e, 0x5f, 0x61, 0x73,
	0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x09,
	0x72, 0x75, 0x6e, 0x41, 0x73, 0x55, 0x73, 0x65, 0x72, 0x12, 0x27, 0x0a, 0x0f, 0x72, 0x65, 0x61,
	0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x66, 0x73, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0e, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x52, 0x6f, 0x6f, 0x74,
	0x66, 0x73, 0x12, 0x2f, 0x0a, 0x13, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
	0x61, 0x6c, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x03, 0x52,
	0x12, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x47, 0x72, 0x6f,
	0x75, 0x70, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65,
	0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65,
	0x67, 0x65, 0x64, 0x12, 0x30, 0x0a, 0x14, 0x73, 0x65, 0x63, 0x63, 0x6f, 0x6d, 0x70, 0x5f, 0x70,
	0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x12, 0x73, 0x65, 0x63, 0x63, 0x6f, 0x6d, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
	0x65, 0x50, 0x61, 0x74, 0x68, 0x22, 0x8c, 0x02, 0x0a, 0x15, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x50,
	0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x23, 0x0a, 0x0d, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x5f, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x50, 0x61,
	0x72, 0x65, 0x6e, 0x74, 0x12, 0x4d, 0x0a, 0x10, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x53, 0x61, 0x6e, 0x64,
	0x62, 0x6f, 0x78, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x65,
	0x78, 0x74, 0x52, 0x0f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x12, 0x43, 0x0a, 0x07, 0x73, 0x79, 0x73, 0x63, 0x74, 0x6c, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x6e,
	0x75, 0x78, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x2e, 0x53, 0x79, 0x73, 0x63, 0x74, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
	0x07, 0x73, 0x79, 0x73, 0x63, 0x74, 0x6c, 0x73, 0x1a, 0x3a, 0x0a, 0x0c, 0x53, 0x79, 0x73, 0x63,
	0x74, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x3a, 0x02, 0x38, 0x01, 0x22, 0x72, 0x0a, 0x12, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10,
	0x0a, 0x03, 0x75, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x69, 0x64,
	0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x07, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x22, 0xac, 0x04, 0x0a, 0x10, 0x50, 0x6f, 0x64,
	0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x35, 0x0a,
	0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65,
	0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x6f, 0x67, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6c, 0x6f, 0x67, 0x44, 0x69, 0x72, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x2f, 0x0a, 0x0a, 0x64, 0x6e, 0x73, 0x5f, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x64, 0x6e, 0x73,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x37, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x6d,
	0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e,
	0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e,
	0x67, 0x52, 0x0c, 0x70, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x73, 0x12,
	0x3b, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x23, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x4a, 0x0a, 0x0b,
	0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x28, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e,
	0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x41, 0x6e, 0x6e, 0x6f, 0x74,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0b, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x05, 0x6c, 0x69, 0x6e, 0x75,
	0x78, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e,
	0x4c, 0x69, 0x6e, 0x75, 0x78, 0x50, 0x6f, 0x64, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x1a, 0x39, 0x0a, 0x0b,
	0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3e, 0x0a, 0x10, 0x41, 0x6e, 0x6e, 0x6f, 0x74,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x21, 0x0a, 0x09, 0x49, 0x6d, 0x61, 0x67, 0x65,
	0x53, 0x70, 0x65, 0x63, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x35, 0x0a, 0x0b, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x05, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61,
	0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67,
	0x65, 0x22, 0x55, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2a, 0x0a, 0x06, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x05, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x22, 0xc0, 0x01, 0x0a, 0x0b, 0x48, 0x65, 0x61,
	0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f,
	0x75, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x69,
	0x6f, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x50,
	0x65, 0x72, 0x69, 0x6f, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12,
	0x2a, 0x0a, 0x11, 0x65, 0x78, 0x69, 0x74, 0x5f, 0x6f, 0x6e, 0x5f, 0x75, 0x6e, 0x68, 0x65, 0x61,
	0x6c, 0x74, 0x68, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x65, 0x78, 0x69, 0x74,
	0x4f, 0x6e, 0x55, 0x6e, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x22, 0xba, 0x02, 0x0a, 0x05,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x70, 0x6f, 0x5f, 0x74, 0x61,
	0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x70, 0x6f, 0x54, 0x61,
	0x67, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x70, 0x6f, 0x5f, 0x64, 0x69, 0x67, 0x65, 0x73,
	0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x72, 0x65, 0x70, 0x6f, 0x44, 0x69,
	0x67, 0x65, 0x73, 0x74, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x23, 0x0a, 0x03, 0x75, 0x69, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49,
	0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x03, 0x75, 0x69, 0x64, 0x12, 0x1a,
	0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x12, 0x24, 0x0a, 0x04,
	0x73, 0x70, 0x65, 0x63, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70,
	0x65, 0x63, 0x12, 0x34, 0x0a, 0x0b, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x63, 0x68, 0x65, 0x63,
	0x6b, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e,
	0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x0b, 0x68, 0x65, 0x61,
	0x6c, 0x74, 0x68, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x22, 0x62, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24,
	0x0a, 0x06, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x06, 0x69, 0x6d,
	0x61, 0x67, 0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02,
	0x63, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x56, 0x0a, 0x12,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x26, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53,
	0x70, 0x65, 0x63, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65,
	0x72, 0x62, 0x6f, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x76, 0x65, 0x72,
	0x62, 0x6f, 0x73, 0x65, 0x22, 0xd4, 0x01, 0x0a, 0x13, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x22, 0x0a, 0x05,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65,
	0x12, 0x38, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72,
	0x72, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d,
	0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02,
	0x63, 0x63, 0x1a, 0x37, 0x0a, 0x09, 0x49, 0x6e, 0x66, 0x6f, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x3a, 0x0a, 0x10, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x26, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63,
	0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x4f, 0x0a, 0x11, 0x49, 0x6d, 0x61, 0x67, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04,
	0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63,
	0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0xcd, 0x01, 0x0a, 0x0a, 0x41, 0x75, 0x74,
	0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12,
	0x12, 0x0a, 0x04, 0x61, 0x75, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x61,
	0x75, 0x74, 0x68, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x73, 0x65, 0x72,
	0x76, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x69, 0x64,
	0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0d, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x54, 0x6f, 0x6b, 0x65,
	0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x72, 0x65, 0x67, 0x69, 0x73,
	0x74, 0x72, 0x79, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0xa1, 0x01, 0x0a, 0x10, 0x50, 0x75, 0x6c,
	0x6c, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x26, 0x0a,
	0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69,
	0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x05,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x25, 0x0a, 0x04, 0x61, 0x75, 0x74, 0x68, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x41, 0x75, 0x74, 0x68,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x61, 0x75, 0x74, 0x68, 0x12, 0x3e, 0x0a, 0x0e,
	0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x6f, 0x64,
	0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x73,
	0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x58, 0x0a, 0x11,
	0x50, 0x75, 0x6c, 0x6c, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x72, 0x65, 0x66, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x66, 0x12, 0x16,
	0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x52, 0x0a, 0x12, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x26, 0x0a, 0x05,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x05, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x22, 0x3d, 0x0a, 0x13, 0x52, 0x65,
	0x6d, 0x6f, 0x76, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x14, 0x0a, 0x12, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x46, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22,
	0x23, 0x0a, 0x0b, 0x55, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x22, 0x27, 0x0a, 0x11, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49,
	0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x22, 0xd0, 0x01,
	0x0a, 0x0f, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x55, 0x73, 0x61, 0x67,
	0x65, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x37, 0x0a, 0x0a, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x09, 0x73,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x64, 0x12, 0x31, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x64,
	0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x69,
	0x73, 0x75, 0x6c, 0x61, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x52, 0x09, 0x75, 0x73, 0x65, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x0b, 0x69,
	0x6e, 0x6f, 0x64, 0x65, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x12, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x52, 0x0a, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x55, 0x73, 0x65, 0x64,
	0x22, 0x82, 0x01, 0x0a, 0x13, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x73, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x43, 0x0a, 0x11, 0x69, 0x6d, 0x61, 0x67,
	0x65, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x46, 0x69, 0x6c, 0x65,
	0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x55, 0x73, 0x61, 0x67, 0x65, 0x52, 0x10, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x16, 0x0a,
	0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65,
	0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x63, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x02, 0x63, 0x63, 0x22, 0x6b, 0x0a, 0x0f, 0x54, 0x61, 0x67, 0x49, 0x6d, 0x61, 0x67,
	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2a, 0x0a, 0x07, 0x73, 0x72, 0x63, 0x4e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x07, 0x73, 0x72, 0x63,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x2c, 0x0a, 0x08, 0x64, 0x65, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x08, 0x64, 0x65, 0x73, 0x74, 0x4e, 0x61,
	0x6d, 0x65, 0x22, 0x3a, 0x0a, 0x10, 0x54, 0x61, 0x67, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x6d, 0x73, 0x67, 0x12, 0x0e,
	0x0a, 0x02, 0x63, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x63, 0x63, 0x2a, 0x1c,
	0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43,
	0x50, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x01, 0x2a, 0x6d, 0x0a, 0x10,
	0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x17, 0x0a, 0x13, 0x50, 0x52, 0x4f, 0x50, 0x41, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f,
	0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x10, 0x00, 0x12, 0x21, 0x0a, 0x1d, 0x50, 0x52, 0x4f,
	0x50, 0x41, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x48, 0x4f, 0x53, 0x54, 0x5f, 0x54, 0x4f,
	0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19,
	0x50, 0x52, 0x4f, 0x50, 0x41, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x42, 0x49, 0x44, 0x49,
	0x52, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x4c, 0x10, 0x02, 0x32, 0xa8, 0x0c, 0x0a, 0x0c,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x43, 0x0a, 0x0a,
	0x4c, 0x69, 0x73, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x12, 0x18, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x73,
	0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x12, 0x46, 0x0a, 0x0b, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x19, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x40, 0x0a, 0x09, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x17, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x18, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x40, 0x0a, 0x09, 0x50,
	0x75, 0x6c, 0x6c, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x17, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61,
	0x2e, 0x50, 0x75, 0x6c, 0x6c, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x18, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x50, 0x75, 0x6c, 0x6c, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a,
	0x0b, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x19, 0x2e, 0x69,
	0x73, 0x75, 0x6c, 0x61, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e,
	0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x0b, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x73,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x19, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x46, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x1a, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x73, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x41, 0x0a,
	0x09, 0x4c, 0x6f, 0x61, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x17, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x6f, 0x61, 0x64,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x6f, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x38, 0x0a, 0x06, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x14, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x16, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x6f, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4f, 0x0a, 0x0e, 0x4c, 0x69,
	0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x12, 0x1c, 0x2e, 0x69,
	0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x55, 0x0a, 0x10, 0x43,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x12,
	0x1e, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x1f, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
	0x72, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x52, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x52,
	0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x1d, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f,
	0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e,
	0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4f, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69,
	0x6e, 0x65, 0x72, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1c, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61,
	0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x74, 0x61,
	0x69, 0x6e, 0x65, 0x72, 0x55, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1d, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x55, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x55, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x0f, 0x43,
	0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x1d,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
	0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e,
	0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x45,
	0x78, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x55, 0x0a, 0x10, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x73, 0x55, 0x73,
	0x61, 0x67, 0x65, 0x12, 0x1e, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74,
	0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x73, 0x55, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74,
	0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x73, 0x55, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x58, 0x0a, 0x11, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64,
	0x72, 0x69, 0x76, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1f, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x69,
	0x73, 0x75, 0x6c, 0x61, 0x2e, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x5e, 0x0a, 0x13, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x21, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e,
	0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x69, 0x73, 0x75,
	0x6c, 0x61, 0x2e, 0x47, 0x72, 0x61, 0x70, 0x68, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x34, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x13, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x37, 0x0a, 0x06, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74,
	0x12, 0x14, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x4c,
	0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x46, 0x0a, 0x0b, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x19,
	0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65,
	0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x69, 0x73, 0x75, 0x6c,
	0x61, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08, 0x54, 0x61, 0x67, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x12, 0x16, 0x2e, 0x69, 0x73, 0x75, 0x6c, 0x61, 0x2e, 0x54, 0x61, 0x67, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x69, 0x73,
	0x75, 0x6c, 0x61, 0x2e, 0x54, 0x61, 0x67, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_isula_image_proto_rawDescOnce sync.Once
	file_isula_image_proto_rawDescData = file_isula_image_proto_rawDesc
)

func file_isula_image_proto_rawDescGZIP() []byte {
	file_isula_image_proto_rawDescOnce.Do(func() {
		file_isula_image_proto_rawDescData = protoimpl.X.CompressGZIP(file_isula_image_proto_rawDescData)
	})
	return file_isula_image_proto_rawDescData
}

var file_isula_image_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_isula_image_proto_msgTypes = make([]protoimpl.MessageInfo, 66)
var file_isula_image_proto_goTypes = []interface{}{
	(Protocol)(0),                       // 0: isula.Protocol
	(MountPropagation)(0),               // 1: isula.MountPropagation
	(*HealthCheckRequest)(nil),          // 2: isula.HealthCheckRequest
	(*HealthCheckResponse)(nil),         // 3: isula.HealthCheckResponse
	(*LoginRequest)(nil),                // 4: isula.LoginRequest
	(*LoginResponse)(nil),               // 5: isula.LoginResponse
	(*LogoutRequest)(nil),               // 6: isula.LogoutRequest
	(*LogoutResponse)(nil),              // 7: isula.LogoutResponse
	(*ContainerExportRequest)(nil),      // 8: isula.ContainerExportRequest
	(*ContainerExportResponse)(nil),     // 9: isula.ContainerExportResponse
	(*LoadImageRequest)(nil),            // 10: isula.LoadImageRequest
	(*LoadImageResponose)(nil),          // 11: isula.LoadImageResponose
	(*ImportRequest)(nil),               // 12: isula.ImportRequest
	(*ImportResponose)(nil),             // 13: isula.ImportResponose
	(*GraphdriverStatusRequest)(nil),    // 14: isula.GraphdriverStatusRequest
	(*GraphdriverStatusResponse)(nil),   // 15: isula.GraphdriverStatusResponse
	(*GraphdriverMetadataRequest)(nil),  // 16: isula.GraphdriverMetadataRequest
	(*GraphdriverMetadataResponse)(nil), // 17: isula.GraphdriverMetadataResponse
	(*ContainerFsUsageRequest)(nil),     // 18: isula.ContainerFsUsageRequest
	(*ContainerFsUsageResponse)(nil),    // 19: isula.ContainerFsUsageResponse
	(*ContainerUmountRequest)(nil),      // 20: isula.ContainerUmountRequest
	(*ContainerUmountResponse)(nil),     // 21: isula.ContainerUmountResponse
	(*ContainerMountRequest)(nil),       // 22: isula.ContainerMountRequest
	(*ContainerMountResponse)(nil),      // 23: isula.ContainerMountResponse
	(*ContainerRemoveRequest)(nil),      // 24: isula.ContainerRemoveRequest
	(*ContainerRemoveResponse)(nil),     // 25: isula.ContainerRemoveResponse
	(*ContainerPrepareRequest)(nil),     // 26: isula.ContainerPrepareRequest
	(*ContainerPrepareResponse)(nil),    // 27: isula.ContainerPrepareResponse
	(*ListContainersRequest)(nil),       // 28: isula.ListContainersRequest
	(*ListContainersResponse)(nil),      // 29: isula.ListContainersResponse
	(*DNSConfig)(nil),                   // 30: isula.DNSConfig
	(*PortMapping)(nil),                 // 31: isula.PortMapping
	(*Mount)(nil),                       // 32: isula.Mount
	(*NamespaceOption)(nil),             // 33: isula.NamespaceOption
	(*Int64Value)(nil),                  // 34: isula.Int64Value
	(*SELinuxOption)(nil),               // 35: isula.SELinuxOption
	(*LinuxSandboxSecurityContext)(nil), // 36: isula.LinuxSandboxSecurityContext
	(*LinuxPodSandboxConfig)(nil),       // 37: isula.LinuxPodSandboxConfig
	(*PodSandboxMetadata)(nil),          // 38: isula.PodSandboxMetadata
	(*PodSandboxConfig)(nil),            // 39: isula.PodSandboxConfig
	(*ImageSpec)(nil),                   // 40: isula.ImageSpec
	(*ImageFilter)(nil),                 // 41: isula.ImageFilter
	(*ListImagesRequest)(nil),           // 42: isula.ListImagesRequest
	(*HealthCheck)(nil),                 // 43: isula.HealthCheck
	(*Image)(nil),                       // 44: isula.Image
	(*ListImagesResponse)(nil),          // 45: isula.ListImagesResponse
	(*ImageStatusRequest)(nil),          // 46: isula.ImageStatusRequest
	(*ImageStatusResponse)(nil),         // 47: isula.ImageStatusResponse
	(*ImageInfoRequest)(nil),            // 48: isula.ImageInfoRequest
	(*ImageInfoResponse)(nil),           // 49: isula.ImageInfoResponse
	(*AuthConfig)(nil),                  // 50: isula.AuthConfig
	(*PullImageRequest)(nil),            // 51: isula.PullImageRequest
	(*PullImageResponse)(nil),           // 52: isula.PullImageResponse
	(*RemoveImageRequest)(nil),          // 53: isula.RemoveImageRequest
	(*RemoveImageResponse)(nil),         // 54: isula.RemoveImageResponse
	(*ImageFsInfoRequest)(nil),          // 55: isula.ImageFsInfoRequest
	(*UInt64Value)(nil),                 // 56: isula.UInt64Value
	(*StorageIdentifier)(nil),           // 57: isula.StorageIdentifier
	(*FilesystemUsage)(nil),             // 58: isula.FilesystemUsage
	(*ImageFsInfoResponse)(nil),         // 59: isula.ImageFsInfoResponse
	(*TagImageRequest)(nil),             // 60: isula.TagImageRequest
	(*TagImageResponse)(nil),            // 61: isula.TagImageResponse
	nil,                                 // 62: isula.GraphdriverMetadataResponse.MetadataEntry
	nil,                                 // 63: isula.ListContainersResponse.ContainersEntry
	nil,                                 // 64: isula.LinuxPodSandboxConfig.SysctlsEntry
	nil,                                 // 65: isula.PodSandboxConfig.LabelsEntry
	nil,                                 // 66: isula.PodSandboxConfig.AnnotationsEntry
	nil,                                 // 67: isula.ImageStatusResponse.InfoEntry
}
var file_isula_image_proto_depIdxs = []int32{
	62, // 0: isula.GraphdriverMetadataResponse.metadata:type_name -> isula.GraphdriverMetadataResponse.MetadataEntry
	63, // 1: isula.ListContainersResponse.containers:type_name -> isula.ListContainersResponse.ContainersEntry
	0,  // 2: isula.PortMapping.protocol:type_name -> isula.Protocol
	1,  // 3: isula.Mount.propagation:type_name -> isula.MountPropagation
	33, // 4: isula.LinuxSandboxSecurityContext.namespace_options:type_name -> isula.NamespaceOption
	35, // 5: isula.LinuxSandboxSecurityContext.selinux_options:type_name -> isula.SELinuxOption
	34, // 6: isula.LinuxSandboxSecurityContext.run_as_user:type_name -> isula.Int64Value
	36, // 7: isula.LinuxPodSandboxConfig.security_context:type_name -> isula.LinuxSandboxSecurityContext
	64, // 8: isula.LinuxPodSandboxConfig.sysctls:type_name -> isula.LinuxPodSandboxConfig.SysctlsEntry
	38, // 9: isula.PodSandboxConfig.metadata:type_name -> isula.PodSandboxMetadata
	30, // 10: isula.PodSandboxConfig.dns_config:type_name -> isula.DNSConfig
	31, // 11: isula.PodSandboxConfig.port_mappings:type_name -> isula.PortMapping
	65, // 12: isula.PodSandboxConfig.labels:type_name -> isula.PodSandboxConfig.LabelsEntry
	66, // 13: isula.PodSandboxConfig.annotations:type_name -> isula.PodSandboxConfig.AnnotationsEntry
	37, // 14: isula.PodSandboxConfig.linux:type_name -> isula.LinuxPodSandboxConfig
	40, // 15: isula.ImageFilter.image:type_name -> isula.ImageSpec
	41, // 16: isula.ListImagesRequest.filter:type_name -> isula.ImageFilter
	34, // 17: isula.Image.uid:type_name -> isula.Int64Value
	40, // 18: isula.Image.spec:type_name -> isula.ImageSpec
	43, // 19: isula.Image.healthcheck:type_name -> isula.HealthCheck
	44, // 20: isula.ListImagesResponse.images:type_name -> isula.Image
	40, // 21: isula.ImageStatusRequest.image:type_name -> isula.ImageSpec
	44, // 22: isula.ImageStatusResponse.image:type_name -> isula.Image
	67, // 23: isula.ImageStatusResponse.info:type_name -> isula.ImageStatusResponse.InfoEntry
	40, // 24: isula.ImageInfoRequest.image:type_name -> isula.ImageSpec
	40, // 25: isula.PullImageRequest.image:type_name -> isula.ImageSpec
	50, // 26: isula.PullImageRequest.auth:type_name -> isula.AuthConfig
	39, // 27: isula.PullImageRequest.sandbox_config:type_name -> isula.PodSandboxConfig
	40, // 28: isula.RemoveImageRequest.image:type_name -> isula.ImageSpec
	57, // 29: isula.FilesystemUsage.storage_id:type_name -> isula.StorageIdentifier
	56, // 30: isula.FilesystemUsage.used_bytes:type_name -> isula.UInt64Value
	56, // 31: isula.FilesystemUsage.inodes_used:type_name -> isula.UInt64Value
	58, // 32: isula.ImageFsInfoResponse.image_filesystems:type_name -> isula.FilesystemUsage
	40, // 33: isula.TagImageRequest.srcName:type_name -> isula.ImageSpec
	40, // 34: isula.TagImageRequest.destName:type_name -> isula.ImageSpec
	42, // 35: isula.ImageService.ListImages:input_type -> isula.ListImagesRequest
	46, // 36: isula.ImageService.ImageStatus:input_type -> isula.ImageStatusRequest
	48, // 37: isula.ImageService.ImageInfo:input_type -> isula.ImageInfoRequest
	51, // 38: isula.ImageService.PullImage:input_type -> isula.PullImageRequest
	53, // 39: isula.ImageService.RemoveImage:input_type -> isula.RemoveImageRequest
	55, // 40: isula.ImageService.ImageFsInfo:input_type -> isula.ImageFsInfoRequest
	10, // 41: isula.ImageService.LoadImage:input_type -> isula.LoadImageRequest
	12, // 42: isula.ImageService.Import:input_type -> isula.ImportRequest
	28, // 43: isula.ImageService.ListContainers:input_type -> isula.ListContainersRequest
	26, // 44: isula.ImageService.ContainerPrepare:input_type -> isula.ContainerPrepareRequest
	24, // 45: isula.ImageService.ContainerRemove:input_type -> isula.ContainerRemoveRequest
	22, // 46: isula.ImageService.ContainerMount:input_type -> isula.ContainerMountRequest
	20, // 47: isula.ImageService.ContainerUmount:input_type -> isula.ContainerUmountRequest
	8,  // 48: isula.ImageService.ContainerExport:input_type -> isula.ContainerExportRequest
	18, // 49: isula.ImageService.ContainerFsUsage:input_type -> isula.ContainerFsUsageRequest
	14, // 50: isula.ImageService.GraphdriverStatus:input_type -> isula.GraphdriverStatusRequest
	16, // 51: isula.ImageService.GraphdriverMetadata:input_type -> isula.GraphdriverMetadataRequest
	4,  // 52: isula.ImageService.Login:input_type -> isula.LoginRequest
	6,  // 53: isula.ImageService.Logout:input_type -> isula.LogoutRequest
	2,  // 54: isula.ImageService.HealthCheck:input_type -> isula.HealthCheckRequest
	60, // 55: isula.ImageService.TagImage:input_type -> isula.TagImageRequest
	45, // 56: isula.ImageService.ListImages:output_type -> isula.ListImagesResponse
	47, // 57: isula.ImageService.ImageStatus:output_type -> isula.ImageStatusResponse
	49, // 58: isula.ImageService.ImageInfo:output_type -> isula.ImageInfoResponse
	52, // 59: isula.ImageService.PullImage:output_type -> isula.PullImageResponse
	54, // 60: isula.ImageService.RemoveImage:output_type -> isula.RemoveImageResponse
	59, // 61: isula.ImageService.ImageFsInfo:output_type -> isula.ImageFsInfoResponse
	11, // 62: isula.ImageService.LoadImage:output_type -> isula.LoadImageResponose
	13, // 63: isula.ImageService.Import:output_type -> isula.ImportResponose
	29, // 64: isula.ImageService.ListContainers:output_type -> isula.ListContainersResponse
	27, // 65: isula.ImageService.ContainerPrepare:output_type -> isula.ContainerPrepareResponse
	25, // 66: isula.ImageService.ContainerRemove:output_type -> isula.ContainerRemoveResponse
	23, // 67: isula.ImageService.ContainerMount:output_type -> isula.ContainerMountResponse
	21, // 68: isula.ImageService.ContainerUmount:output_type -> isula.ContainerUmountResponse
	9,  // 69: isula.ImageService.ContainerExport:output_type -> isula.ContainerExportResponse
	19, // 70: isula.ImageService.ContainerFsUsage:output_type -> isula.ContainerFsUsageResponse
	15, // 71: isula.ImageService.GraphdriverStatus:output_type -> isula.GraphdriverStatusResponse
	17, // 72: isula.ImageService.GraphdriverMetadata:output_type -> isula.GraphdriverMetadataResponse
	5,  // 73: isula.ImageService.Login:output_type -> isula.LoginResponse
	7,  // 74: isula.ImageService.Logout:output_type -> isula.LogoutResponse
	3,  // 75: isula.ImageService.HealthCheck:output_type -> isula.HealthCheckResponse
	61, // 76: isula.ImageService.TagImage:output_type -> isula.TagImageResponse
	56, // [56:77] is the sub-list for method output_type
	35, // [35:56] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_isula_image_proto_init() }
func file_isula_image_proto_init() {
	if File_isula_image_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_isula_image_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HealthCheckRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HealthCheckResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoginRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoginResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogoutRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogoutResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerExportRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerExportResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadImageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadImageResponose); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImportRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImportResponose); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GraphdriverStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GraphdriverStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GraphdriverMetadataRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GraphdriverMetadataResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerFsUsageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerFsUsageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerUmountRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerUmountResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerMountRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerMountResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerRemoveRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerRemoveResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerPrepareRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContainerPrepareResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListContainersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListContainersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DNSConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PortMapping); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Mount); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NamespaceOption); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Int64Value); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SELinuxOption); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinuxSandboxSecurityContext); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinuxPodSandboxConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PodSandboxMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PodSandboxConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageFilter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListImagesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HealthCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Image); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListImagesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AuthConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PullImageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PullImageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveImageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveImageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageFsInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UInt64Value); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[55].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageIdentifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilesystemUsage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[57].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageFsInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[58].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TagImageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_isula_image_proto_msgTypes[59].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TagImageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_isula_image_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   66,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_isula_image_proto_goTypes,
		DependencyIndexes: file_isula_image_proto_depIdxs,
		EnumInfos:         file_isula_image_proto_enumTypes,
		MessageInfos:      file_isula_image_proto_msgTypes,
	}.Build()
	File_isula_image_proto = out.File
	file_isula_image_proto_rawDesc = nil
	file_isula_image_proto_goTypes = nil
	file_isula_image_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImageServiceClient interface {
	// ListImages lists existing images.
	ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error)
	// ImageStatus returns the status of the image. If the image is not
	// present, returns a response with ImageStatusResponse.Image set to
	// nil.
	ImageStatus(ctx context.Context, in *ImageStatusRequest, opts ...grpc.CallOption) (*ImageStatusResponse, error)
	//  Get image information
	ImageInfo(ctx context.Context, in *ImageInfoRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error)
	// PullImage pulls an image with authentication config.
	PullImage(ctx context.Context, in *PullImageRequest, opts ...grpc.CallOption) (*PullImageResponse, error)
	// RemoveImage removes the image.
	// This call is idempotent, and must not return an error if the image has
	// already been removed.
	RemoveImage(ctx context.Context, in *RemoveImageRequest, opts ...grpc.CallOption) (*RemoveImageResponse, error)
	// ImageFSInfo returns information of the filesystem that is used to store images.
	ImageFsInfo(ctx context.Context, in *ImageFsInfoRequest, opts ...grpc.CallOption) (*ImageFsInfoResponse, error)
	// Load image from file
	LoadImage(ctx context.Context, in *LoadImageRequest, opts ...grpc.CallOption) (*LoadImageResponose, error)
	// Import rootfs to be image
	Import(ctx context.Context, in *ImportRequest, opts ...grpc.CallOption) (*ImportResponose, error)
	// isulad image services
	// get all Container rootfs
	ListContainers(ctx context.Context, in *ListContainersRequest, opts ...grpc.CallOption) (*ListContainersResponse, error)
	// create rootfs for container
	ContainerPrepare(ctx context.Context, in *ContainerPrepareRequest, opts ...grpc.CallOption) (*ContainerPrepareResponse, error)
	// remove rootfs of container
	ContainerRemove(ctx context.Context, in *ContainerRemoveRequest, opts ...grpc.CallOption) (*ContainerRemoveResponse, error)
	// mount rwlayer for container
	ContainerMount(ctx context.Context, in *ContainerMountRequest, opts ...grpc.CallOption) (*ContainerMountResponse, error)
	// umount rwlayer of container
	ContainerUmount(ctx context.Context, in *ContainerUmountRequest, opts ...grpc.CallOption) (*ContainerUmountResponse, error)
	// export container rootfs
	ContainerExport(ctx context.Context, in *ContainerExportRequest, opts ...grpc.CallOption) (*ContainerExportResponse, error)
	// get filesystem usage of container
	ContainerFsUsage(ctx context.Context, in *ContainerFsUsageRequest, opts ...grpc.CallOption) (*ContainerFsUsageResponse, error)
	// get status of graphdriver
	GraphdriverStatus(ctx context.Context, in *GraphdriverStatusRequest, opts ...grpc.CallOption) (*GraphdriverStatusResponse, error)
	// get metadata of graphdriver
	GraphdriverMetadata(ctx context.Context, in *GraphdriverMetadataRequest, opts ...grpc.CallOption) (*GraphdriverMetadataResponse, error)
	// login registry
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// logout registry
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	// health check service
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Add a tag to the image
	TagImage(ctx context.Context, in *TagImageRequest, opts ...grpc.CallOption) (*TagImageResponse, error)
}

type imageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error) {
	out := new(ListImagesResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ListImages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ImageStatus(ctx context.Context, in *ImageStatusRequest, opts ...grpc.CallOption) (*ImageStatusResponse, error) {
	out := new(ImageStatusResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ImageStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ImageInfo(ctx context.Context, in *ImageInfoRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error) {
	out := new(ImageInfoResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ImageInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) PullImage(ctx context.Context, in *PullImageRequest, opts ...grpc.CallOption) (*PullImageResponse, error) {
	out := new(PullImageResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/PullImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) RemoveImage(ctx context.Context, in *RemoveImageRequest, opts ...grpc.CallOption) (*RemoveImageResponse, error) {
	out := new(RemoveImageResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/RemoveImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ImageFsInfo(ctx context.Context, in *ImageFsInfoRequest, opts ...grpc.CallOption) (*ImageFsInfoResponse, error) {
	out := new(ImageFsInfoResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ImageFsInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) LoadImage(ctx context.Context, in *LoadImageRequest, opts ...grpc.CallOption) (*LoadImageResponose, error) {
	out := new(LoadImageResponose)
	err := c.cc.Invoke(ctx, "/isula.ImageService/LoadImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Import(ctx context.Context, in *ImportRequest, opts ...grpc.CallOption) (*ImportResponose, error) {
	out := new(ImportResponose)
	err := c.cc.Invoke(ctx, "/isula.ImageService/Import", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ListContainers(ctx context.Context, in *ListContainersRequest, opts ...grpc.CallOption) (*ListContainersResponse, error) {
	out := new(ListContainersResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ListContainers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerPrepare(ctx context.Context, in *ContainerPrepareRequest, opts ...grpc.CallOption) (*ContainerPrepareResponse, error) {
	out := new(ContainerPrepareResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerPrepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerRemove(ctx context.Context, in *ContainerRemoveRequest, opts ...grpc.CallOption) (*ContainerRemoveResponse, error) {
	out := new(ContainerRemoveResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerMount(ctx context.Context, in *ContainerMountRequest, opts ...grpc.CallOption) (*ContainerMountResponse, error) {
	out := new(ContainerMountResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerMount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerUmount(ctx context.Context, in *ContainerUmountRequest, opts ...grpc.CallOption) (*ContainerUmountResponse, error) {
	out := new(ContainerUmountResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerUmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerExport(ctx context.Context, in *ContainerExportRequest, opts ...grpc.CallOption) (*ContainerExportResponse, error) {
	out := new(ContainerExportResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerExport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ContainerFsUsage(ctx context.Context, in *ContainerFsUsageRequest, opts ...grpc.CallOption) (*ContainerFsUsageResponse, error) {
	out := new(ContainerFsUsageResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/ContainerFsUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) GraphdriverStatus(ctx context.Context, in *GraphdriverStatusRequest, opts ...grpc.CallOption) (*GraphdriverStatusResponse, error) {
	out := new(GraphdriverStatusResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/GraphdriverStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) GraphdriverMetadata(ctx context.Context, in *GraphdriverMetadataRequest, opts ...grpc.CallOption) (*GraphdriverMetadataResponse, error) {
	out := new(GraphdriverMetadataResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/GraphdriverMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/HealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) TagImage(ctx context.Context, in *TagImageRequest, opts ...grpc.CallOption) (*TagImageResponse, error) {
	out := new(TagImageResponse)
	err := c.cc.Invoke(ctx, "/isula.ImageService/TagImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
type ImageServiceServer interface {
	// ListImages lists existing images.
	ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error)
	// ImageStatus returns the status of the image. If the image is not
	// present, returns a response with ImageStatusResponse.Image set to
	// nil.
	ImageStatus(context.Context, *ImageStatusRequest) (*ImageStatusResponse, error)
	//  Get image information
	ImageInfo(context.Context, *ImageInfoRequest) (*ImageInfoResponse, error)
	// PullImage pulls an image with authentication config.
	PullImage(context.Context, *PullImageRequest) (*PullImageResponse, error)
	// RemoveImage removes the image.
	// This call is idempotent, and must not return an error if the image has
	// already been removed.
	RemoveImage(context.Context, *RemoveImageRequest) (*RemoveImageResponse, error)
	// ImageFSInfo returns information of the filesystem that is used to store images.
	ImageFsInfo(context.Context, *ImageFsInfoRequest) (*ImageFsInfoResponse, error)
	// Load image from file
	LoadImage(context.Context, *LoadImageRequest) (*LoadImageResponose, error)
	// Import rootfs to be image
	Import(context.Context, *ImportRequest) (*ImportResponose, error)
	// isulad image services
	// get all Container rootfs
	ListContainers(context.Context, *ListContainersRequest) (*ListContainersResponse, error)
	// create rootfs for container
	ContainerPrepare(context.Context, *ContainerPrepareRequest) (*ContainerPrepareResponse, error)
	// remove rootfs of container
	ContainerRemove(context.Context, *ContainerRemoveRequest) (*ContainerRemoveResponse, error)
	// mount rwlayer for container
	ContainerMount(context.Context, *ContainerMountRequest) (*ContainerMountResponse, error)
	// umount rwlayer of container
	ContainerUmount(context.Context, *ContainerUmountRequest) (*ContainerUmountResponse, error)
	// export container rootfs
	ContainerExport(context.Context, *ContainerExportRequest) (*ContainerExportResponse, error)
	// get filesystem usage of container
	ContainerFsUsage(context.Context, *ContainerFsUsageRequest) (*ContainerFsUsageResponse, error)
	// get status of graphdriver
	GraphdriverStatus(context.Context, *GraphdriverStatusRequest) (*GraphdriverStatusResponse, error)
	// get metadata of graphdriver
	GraphdriverMetadata(context.Context, *GraphdriverMetadataRequest) (*GraphdriverMetadataResponse, error)
	// login registry
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// logout registry
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	// health check service
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Add a tag to the image
	TagImage(context.Context, *TagImageRequest) (*TagImageResponse, error)
}

// UnimplementedImageServiceServer can be embedded to have forward compatible implementations.
type UnimplementedImageServiceServer struct {
}

func (*UnimplementedImageServiceServer) ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImages not implemented")
}
func (*UnimplementedImageServiceServer) ImageStatus(context.Context, *ImageStatusRequest) (*ImageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImageStatus not implemented")
}
func (*UnimplementedImageServiceServer) ImageInfo(context.Context, *ImageInfoRequest) (*ImageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImageInfo not implemented")
}
func (*UnimplementedImageServiceServer) PullImage(context.Context, *PullImageRequest) (*PullImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullImage not implemented")
}
func (*UnimplementedImageServiceServer) RemoveImage(context.Context, *RemoveImageRequest) (*RemoveImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveImage not implemented")
}
func (*UnimplementedImageServiceServer) ImageFsInfo(context.Context, *ImageFsInfoRequest) (*ImageFsInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImageFsInfo not implemented")
}
func (*UnimplementedImageServiceServer) LoadImage(context.Context, *LoadImageRequest) (*LoadImageResponose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadImage not implemented")
}
func (*UnimplementedImageServiceServer) Import(context.Context, *ImportRequest) (*ImportResponose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Import not implemented")
}
func (*UnimplementedImageServiceServer) ListContainers(context.Context, *ListContainersRequest) (*ListContainersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContainers not implemented")
}
func (*UnimplementedImageServiceServer) ContainerPrepare(context.Context, *ContainerPrepareRequest) (*ContainerPrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerPrepare not implemented")
}
func (*UnimplementedImageServiceServer) ContainerRemove(context.Context, *ContainerRemoveRequest) (*ContainerRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerRemove not implemented")
}
func (*UnimplementedImageServiceServer) ContainerMount(context.Context, *ContainerMountRequest) (*ContainerMountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerMount not implemented")
}
func (*UnimplementedImageServiceServer) ContainerUmount(context.Context, *ContainerUmountRequest) (*ContainerUmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerUmount not implemented")
}
func (*UnimplementedImageServiceServer) ContainerExport(context.Context, *ContainerExportRequest) (*ContainerExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerExport not implemented")
}
func (*UnimplementedImageServiceServer) ContainerFsUsage(context.Context, *ContainerFsUsageRequest) (*ContainerFsUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerFsUsage not implemented")
}
func (*UnimplementedImageServiceServer) GraphdriverStatus(context.Context, *GraphdriverStatusRequest) (*GraphdriverStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GraphdriverStatus not implemented")
}
func (*UnimplementedImageServiceServer) GraphdriverMetadata(context.Context, *GraphdriverMetadataRequest) (*GraphdriverMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GraphdriverMetadata not implemented")
}
func (*UnimplementedImageServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedImageServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (*UnimplementedImageServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (*UnimplementedImageServiceServer) TagImage(context.Context, *TagImageRequest) (*TagImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagImage not implemented")
}

func RegisterImageServiceServer(s *grpc.Server, srv ImageServiceServer) {
	s.RegisterService(&_ImageService_serviceDesc, srv)
}

func _ImageService_ListImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ListImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ListImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ListImages(ctx, req.(*ListImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ImageStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ImageStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ImageStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ImageStatus(ctx, req.(*ImageStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ImageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ImageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ImageInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ImageInfo(ctx, req.(*ImageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_PullImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).PullImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/PullImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).PullImage(ctx, req.(*PullImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_RemoveImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).RemoveImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/RemoveImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).RemoveImage(ctx, req.(*RemoveImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ImageFsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageFsInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ImageFsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ImageFsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ImageFsInfo(ctx, req.(*ImageFsInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_LoadImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).LoadImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/LoadImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).LoadImage(ctx, req.(*LoadImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Import_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Import(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/Import",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Import(ctx, req.(*ImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ListContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContainersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ListContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ListContainers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ListContainers(ctx, req.(*ListContainersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerPrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerPrepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerPrepare(ctx, req.(*ContainerPrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerRemove(ctx, req.(*ContainerRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerMount(ctx, req.(*ContainerMountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerUmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerUmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerUmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerUmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerUmount(ctx, req.(*ContainerUmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerExport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerExport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerExport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerExport(ctx, req.(*ContainerExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ContainerFsUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerFsUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ContainerFsUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/ContainerFsUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ContainerFsUsage(ctx, req.(*ContainerFsUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_GraphdriverStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphdriverStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).GraphdriverStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/GraphdriverStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).GraphdriverStatus(ctx, req.(*GraphdriverStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_GraphdriverMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphdriverMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).GraphdriverMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/GraphdriverMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).GraphdriverMetadata(ctx, req.(*GraphdriverMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_TagImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).TagImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/isula.ImageService/TagImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).TagImage(ctx, req.(*TagImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "isula.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListImages",
			Handler:    _ImageService_ListImages_Handler,
		},
		{
			MethodName: "ImageStatus",
			Handler:    _ImageService_ImageStatus_Handler,
		},
		{
			MethodName: "ImageInfo",
			Handler:    _ImageService_ImageInfo_Handler,
		},
		{
			MethodName: "PullImage",
			Handler:    _ImageService_PullImage_Handler,
		},
		{
			MethodName: "RemoveImage",
			Handler:    _ImageService_RemoveImage_Handler,
		},
		{
			MethodName: "ImageFsInfo",
			Handler:    _ImageService_ImageFsInfo_Handler,
		},
		{
			MethodName: "LoadImage",
			Handler:    _ImageService_LoadImage_Handler,
		},
		{
			MethodName: "Import",
			Handler:    _ImageService_Import_Handler,
		},
		{
			MethodName: "ListContainers",
			Handler:    _ImageService_ListContainers_Handler,
		},
		{
			MethodName: "ContainerPrepare",
			Handler:    _ImageService_ContainerPrepare_Handler,
		},
		{
			MethodName: "ContainerRemove",
			Handler:    _ImageService_ContainerRemove_Handler,
		},
		{
			MethodName: "ContainerMount",
			Handler:    _ImageService_ContainerMount_Handler,
		},
		{
			MethodName: "ContainerUmount",
			Handler:    _ImageService_ContainerUmount_Handler,
		},
		{
			MethodName: "ContainerExport",
			Handler:    _ImageService_ContainerExport_Handler,
		},
		{
			MethodName: "ContainerFsUsage",
			Handler:    _ImageService_ContainerFsUsage_Handler,
		},
		{
			MethodName: "GraphdriverStatus",
			Handler:    _ImageService_GraphdriverStatus_Handler,
		},
		{
			MethodName: "GraphdriverMetadata",
			Handler:    _ImageService_GraphdriverMetadata_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _ImageService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _ImageService_Logout_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _ImageService_HealthCheck_Handler,
		},
		{
			MethodName: "TagImage",
			Handler:    _ImageService_TagImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "isula_image.proto",
}
